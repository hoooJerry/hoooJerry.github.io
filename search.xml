<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读古董局中局后感]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%AF%BB%E5%8F%A4%E8%91%A3%E5%B1%80%E4%B8%AD%E5%B1%80%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[鉴古易，鉴人难 还是没挡住小说的诱惑，抱起我的kindle，在暑假的空当用了三天时间看完了98万字的《古董局中局》，真是感慨颇多呀。 故事很精彩，情节紧凑，可以说是精彩纷呈。其实啊，让我最惊喜的是，它竟然是6年前那个寻常的暑假里，我在收音机中听到的那个小说。 作者的四本书，讲了四个故事，用许家和三代老朝奉的较量历程，作为一条明线穿之。 从民国到90年代，70年风雨，古董行当几经沉浮，赝品产业的日益壮大已经开始撼动五脉的权威。因为古董，就讲究一个“真”字，如果名节不保，买卖自然就断了，但是如今，制假、售假已然壮大，制作精良、工艺成熟，每一件仿冒品背后，都是机关算尽的机巧和匪夷所思的圈套。而这一切的背后，一定是有一个强大的势力运作，是的，老朝奉确为幕后主使。 第一部中，佛头遗案，让许愿这个毛头小子和五脉扯上了关系。明眼梅花，这个古老却美好的名词第一次被我所知道，它象征着古代鉴宝人最为严谨的态度，无论任何情况，不欺人，不骗人。去伪存真，是做人永远的底线。 第二部，清明上河图。外国古董行企图摧毁五脉势力进入中国大肆掠夺资本，许愿心急，导致错误连连、漏洞百出，被人一直牵着鼻子走。后来，和老朝奉暂时联手，却真的击败了百瑞莲。这给我们的启示是，火急攻心，心智也会受到影响，做事永远不要急于求成，送上门的线索不要用。 第三部，掠宝清单。这部是讲的许愿的爷爷许一城的故事。被许一城圈了粉，一个做事有勇有谋，生死一诺，不负嘱托的真汉子。他只身一人挡在孙殿英的军队前面，试图以一己之力阻挡大军。纵使失败，无怨无悔。 第四部，青花瓷宝罐。这部作为大结局，解开了所有的谜团，为什么药不然会加入老朝奉，为什么郑教授会对老朝奉言听计从，老朝奉究竟是何许人也？一个个惊心动魄的探险，一次次精彩无比的推理，让老朝奉的面目逐渐浮现----青字门掌门人，沈云琛，或者叫姬云琛。最后关头，本以为会述尽前世今生，道完沈家与许家的恩怨情仇。然而？ 一个想替父亲报仇的女儿？一段不为人知的童年阴影？一个不得已的苦衷？别天真了，没有！这根本用不着什么矫情的理由。我发现制假赚钱多，盗卖利益大，就干了，没有什么心路曲折，也没什么道德挣扎。 或许真的是这样，或许不是。但这确实符合这个半路杀进来的青字门掌门人的人物形象。她的父亲就是制假贩假，被许一城的妻子带入京城，养在沈家，改姓为沈。她从骨子里，就没有“真”这个底线，利欲熏心，和她的父亲一样。 这四本小说里，有义薄云天的兄弟之情，有令人动容的生死之诺，有推理，有搞笑，有儿女情长，也有百味人生。 梦里说那世间混沌，悲痛，恨，恨就恨蚍蜉撼树，力量单薄。 先须挽取天上水，洗尽人间污浊心。 生在乱世，没人可以自保；生在盛世，惟愿昌鸿延年。 不得不说一下最近的香港暴乱，一个国际化的大都市，一个那么繁荣的地方，为何会有这么多的废青，会被西方势力所操控，那么卖命，好像天经地义。这不由得让我重新审视，那个表面光鲜、内部黑暗的社会，这就是资本主义，我不认为政府有错，政府永远为了社会的繁荣和稳定而在努力，但是商人不同，就像是那个小学生写的，“我要感谢诚哥”，这就是资本主义，那1%的人，掌握着全香港一半以上的财富，底层的人，世世代代生活在平民区，甚至是贫民区，一间20平米的房子，挤满了一家老小，因为读好大学才能有好工作，读好大学就要有个好高中，好初中，好小学，但他们没钱啊，没钱让子女接受更好的教育，只好放任自流。于是，没知识没文化的废青越来越多，他们更容易被洗脑，被煽动，做出那么多匪夷所思，丧尽天良的事。而且，美狗，真是越来越不要脸了，染指香港，如此明目张胆。当时我还在想，咋会这么多人暴乱呢，后来看报道，原来是一天3000啊，怪不得争先恐后的去（不过要是我，就直接抢钱跑人，你美狗不是有钱吗，来呀，越多越好，给3000拿3000，给10000拿10000，大家不都是带着口罩，管你谁是谁，拿钱跑就完事了）。明眼的香港市民都看出了美狗的把戏，但是废青们都看不透呀。阿sir当时说： 但是他们是中国人，打也不是，不打也不是，让人痛心。 我想说，他们早就不是中国人了。请港警们拿好手中的警棍，带好头盔，护目镜，穿好防弹衣，在保护好自身安全的情况下打断他们的狗腿吧，不要心软，不要留情，他们又没有拿出身份证，怎么能说他们是中国人呢？说汉语的又不都是中国人，黄种人也不都是中国人，完全可以认为，暴徒之类都是间谍，虽然香港没有间谍法，但是完全可以对他们实施任何的手段。以暴制暴，是在非常时期的最有效手段，只有棍棒、鲜血，甚至刀、枪，或许能给那些麻木的灵魂一点警醒，一点震慑。 至于BBC之流的无良媒体，我只想说：呵呵。脱欧都让腐国焦头烂额换了三任首相，还有什么脸来对中国主权指手画脚，事件报道颠倒黑白、混淆视听。这种意识形态的对立，已经击碎了一个世界知名媒体的底线，它们已经忘却了作为媒体人应有的良知。是的，它们似那沈云琛，都丢掉了“真”这个底线（动物它哦）。既然贵国的教育没有教好你们，总有一日，会让贵社的主页挂上中国国旗，教你做人，啊不，教你做x。 好了好了，最近几日甚是烦闷，胸中郁积还是一吐为快的好，说出来，也舒服多了。 最后，想用《古董局中局》中的语句结尾—— 人心堕落，世道再乱，还能乱过那会儿么？ 海面黑暗，可天上的群星依然璀璨。]]></content>
      <categories>
        <category>读后感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（二）]]></title>
    <url>%2F2019%2F07%2F31%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[WEB API Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API(BOM 和 DOM)。 BOM的顶级对象 window 对话框 alert()：显示带有一段消息和一个确认按钮的警告框。 prompt():显示可提示用户输入的对话框。 confirm():显示带有一段消息以及确认按钮和取消按钮的对话框。 时间加载对象 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&#125; onunload 123window.onunload = function () &#123; // 当用户退出页面时执行&#125; 浏览器尺寸 1234567var width = window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var height = window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; 定时器 setTimeout(function(){},1000) 方法在指定的毫秒数到达之后执行指定的函数，只执行一次。clearTimeout() 方法取消由 setTimeout() 方法设置的 timeout。 setInterval() 方法设置定时调用的函数也就是可以按照给定的时间(单位毫秒)周期调用函数，clearInterval() 方法取消由setInterval() 方法设置的 timeout。 DOM HTML 改变 HTML 输出流 docuument.write() 改变HTML内容 document.getElementById().innerHTML = 改变HTML属性 document.getElementById(id).attribute = new value 改变CSS样式 document.getElementById(id).style.property=new style property是具体的属性比如说color 通过标签名找到HTML元素 123456789101112&lt;html&gt; &lt;body&gt; &lt;input type="text" /&gt; &lt;input type="text" /&gt; &lt;script&gt; document.getElementsByTagName("input")[0].value="hello"; // 下标为 [0] 表示选取第 1 个 input 标签 document.getElementsByTagName("input")[1].value="shiyanlou"; // 下标为 [1] 表示选取第 2 个 input 标签 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM结点操作 创建结点 创建元素节点：使用 createElement()方法 比如： var par = document.createElement(&quot;p&quot;); 创建属性节点：使用 createAttribute()方法。 创建文本节点：使用 createTextNode()方法。 插入子节点 appendChild ()方法向节点添加最后一个子节点。 insertBefore (插入的新的子节点，指定的子节点)方法在指定的子节点前面插入新的子节点。如果第二个参数没写或者为 null，则默认插入到后面。 删除结点 使用removeChild() 方法 12父节点.removeChild(子节点);node.parentNode.removeChild(node); //如果不知道父节点是什么，可以这样写 替换子节点 使用 node.replaceChild(newnode,oldnode) 方法。 设置节点的属性 获取：getAttribute(名称) 设置：setAttribute(名称, 值) 删除：removeAttribute(名称) DOM事件 事件三要素 事件由：事件源 + 事件类型 + 事件处理程序组成。 事件源：触发事件的元素。 事件类型：事件的触发方式(比如鼠标点击或键盘点击)。 事件处理程序：事件触发后要执行的代码(函数形式，匿名函数)。 事件名 说明 onclick 鼠标单击 ondblclick 鼠标双击 onkeyup 按下并释放键盘上一个键时触发 onchange 文本内容或下拉菜单中的选项发生改变 onfocus 获得焦点，表示文本框等获得鼠标光标。 onblur 失去焦点，表示文本框等失去鼠标光标。 onmouseover 鼠标悬停，即鼠标停留在图片等的上方 onmouseout 鼠标移出，即离开图片等所在的区域 onload 网页文档加载事件 onunload 关闭网页时 onsubmit 表单提交事件 onreset 重置表单 例子1.鼠标单击事件 &lt;p onclick=&quot;this.innerHTML='我爱学习，身体好好!'&quot;&gt;请点击该文本&lt;/p&gt; 例子2.鼠标双击事件 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 ondblclick="changetext(this)"&gt;请点击该文本&lt;/h1&gt; &lt;script&gt; function changetext(id) &#123; id.innerHTML = "我爱学习，身体棒棒!" &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 异常处理 try-catch语句捕获异常 12345try&#123; //这里写可能出现异常的代码&#125;catch(err)&#123; //在这里写，出现异常后的处理代码&#125; 需要注意以下几点： 语句 try 和 catch 是成对出现的。 如果在 try 中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中，catch 处理错误信息，然后再执行后面的代码。 如果 try 中没有出现错误，则不会执行 catch 中的代码，直接执行后面的代码。通过 try-catch 语句进行异常捕获之后，代码将会继续执行，而不会中断。 throw语句 通过throw语句我们可以创建自定义错误 面向对象编程 什么是对象 ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。我们可以从以下两个层次来理解对象到底是什么。 对象是单个事物的抽象。比如一支笔，一本书，一辆车都可以是一个对象。 对象是一个容器，封装了属性和方法。比如：一辆车。它的颜色，大小，重量等是它的属性，而启动，加速，减速，刹车等是它的方法。 什么是面向对象编程 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 🌰举个栗子 普通代码面向对象123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div,p&#123; width: 200px; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好吗？&lt;/div&gt; &lt;p&gt;我很好&lt;/p&gt; &lt;div&gt;测试一下嘛&lt;/div&gt; &lt;p&gt;好的啊&lt;/p&gt; &lt;script&gt; function getTagname(tagName)&#123; return document.getElementsByTagName(tagName); &#125; function setStyle(arr)&#123; for(var i = 0;i &lt; arr.length;i++)&#123; arr[i].style.backgroundColor = "red"; &#125; &#125; var divs = getTagname("div"); setStyle(divs); var ps = getTagname("p"); setStyle(ps); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div, p &#123; width: 200px; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好吗？&lt;/div&gt; &lt;p&gt;我很好&lt;/p&gt; &lt;div&gt;测试一下嘛&lt;/div&gt; &lt;p&gt;好的啊&lt;/p&gt; &lt;script&gt; var test = &#123; getEle: &#123; //实际上本案例只需要写 tag，但是为了体现面向对象的思想，我们把获取获取节点的三种方式都写出来 tag: function(tagName) &#123; return document.getElementsByTagName(tagName); &#125;, id: function(idName) &#123; return document.getElementById(idName); &#125;, class: function(className) &#123; return document.getElementsByClassName(className); &#125; &#125;, //实际上本案例只需要写 setStyle，同样的为了体现面向对象编程的思想，我们可以设置添加移除修改样式的函数。 setCss: &#123; setStyle: function(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; arr[i].style.backgroundColor = "red"; &#125; &#125;, updateCss: function() &#123;&#125;, deleteCss: function() &#123;&#125; // ... &#125; &#125;; var divs = test.getEle.tag("div"); test.setCss.setStyle(divs); var ps = test.getEle.tag("p"); test.setCss.setStyle(ps); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 构造函数 💨构造对象 123456789function Student(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; this.sayHi = function()&#123; console.log("hi,my name is "+this.name); &#125;&#125;var s1 = new Student('zhangsan', 18, 'male'); 是不是有点神奇？让我们再回忆一下工厂函数 123456789101112function createStudent(name, age, gender) &#123; var student = new Object(); student.name = name; student.age = age; student.gender = gender; student.sayHi = function()&#123; console.log("hi,my name is "+this.name); &#125; return student;&#125;var s1 = createStudent('zhangsan', 18, 'male');var s2 = createStudent('lisi', 19, 'male'); 来看看构造函数与工厂函数的区别： 首先在构造函数内没有创建对象，而是使用 this 关键字，将属性和方法赋给了 this 对象。 构造函数内没有 return 语句，this 属性默认下是构造函数的返回值。 函数名使用的是大写的 Student。 用 new 运算符和类名 Student 创建对象。 原型: prototype 在 JavaScript 中，每一个函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 12345678910111213function Student(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Student.prototype.sayHi = function()&#123; console.log("hi");&#125;var s1 = new Student('zhangsan', 18, 'male');s1.sayHi();//打印 hivar s2 = new Student('lisi', 18, 'male');s2.sayHi();//打印 hiconsole.log(s1.sayHi == s2.sayHi);//结果为true 构造函数、实例、原型三者之间的关系 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 12function F() &#123;&#125;console.log(F.prototype.constructor === F);//结果为ture 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针__proto__。__proto__属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性。在控制台中运行下面的代码： 123function F() &#123;&#125;var a = new F();console.log(a.__proto__ === F.prototype); //结果为true 实例对象可以直接访问原型对象成员。所有实例都直接或间接继承了原型对象的成员。 总结： 每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针 constructor，而实例都包含一个指向原型对象的内部指针__proto__ 。 属性搜索原则 属性搜索原则，也就是属性的查找顺序，在访问对象的成员的时候，会遵循以下原则： 首先从对象实例本身开始找，如果找到了这个属性或者方法，则返回。 如果对象实例本身没有找到，就从它的原型中去找，如果找到了，则返回。 如果对象实例的原型中也没找到，则从它的原型的原型中去找，如果找到了，则返回。 一直按着原型链查找下去，找到就返回，如果在原型链的末端还没有找到的话，那么如果查找的是属性则返回 undefined，如果查找的是方法则返回 xxx is not a function。 12345678910111213function Student(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Student.prototype = &#123; hobby:"study", sayHi:function()&#123; console.log("hi"); &#125;&#125;var s1 = new Student("wangwu",18,"male");console.log(Student.prototype.constructor === Student);//结果为 false 这样写也有一个问题，那就是原型对象丢失了 constructor 成员。所以为了保持 constructor 成员的指向正确，建议的写法是： 1234567891011121314function Student(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Student.prototype = &#123; constructor: Student, //手动将 constructor 指向正确的构造函数 hobby:"study", sayHi:function()&#123; console.log("hi"); &#125;&#125;var s1 = new Student("wangwu",18,"male");console.log(Student.prototype.constructor === Student);//结果为 true 原型链继承 子承父业，JavaScript 中也有继承。接下来我们会学习原型链继承。原型链继承的主要思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。 123456789101112function Student(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Student.prototype.sayHi = function()&#123; console.log("hi");&#125;var s1 = new Student("zhangsan",18,"male");s1.sayHi(); //打印 hivar s2 = new Student("lisi",18,"male");s2.sayHi(); //打印 hi 函数进阶 call call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。语法为： fun.call(thisArg, arg1, arg2, ...) 注： thisArg 指的是在 fun 函数中指定的 this 的值。如果指定了 null 或者 undefined 则内部 this 指向 window，同时值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象。是一个可选项。 arg1, arg2, …指定的参数列表。也是可选项。 使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。 call() 允许为不同的对象分配和调用属于一个对象的函数/方法。 call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 改写前改写后1234567891011121314function foods() &#123;&#125;foods.prototype = &#123;price: "￥15",say: function() &#123;console.log("My price is " + this.price);&#125;&#125;var apple = new foods();apple.say(); //My price is ￥15var orange = new foods();orange.say(); // My price is ￥15 定义了两遍say方法123456789101112131415function foods() &#123;&#125;foods.prototype = &#123;price: "￥15",say: function() &#123;console.log("My price is " + this.price);&#125;&#125;var apple = new foods();orange = &#123;price: "￥10"&#125;apple.say.call(orange); // My price is ￥10 在一个子构造函数中可以调用父构造函数的call()方法实现继承 123456789101112function Father(name, age) &#123; this.name = name; this.age = age;&#125;function Son(name, age) &#123; Father.call(this, name, age); this.hobby = 'study';&#125;var S1 = new Son('zhangsan', 18);S1; // Son &#123;name: "zhangsan", age: 18, hobby: "study"&#125; apply() apply() 方法与 call() 方法类似，唯一的区别是 call() 方法接受的是参数，apply() 方法接受的是数组。语法为： fun.apply(thisArg, [argsArray]) 使用apply()方法与push()方法联合将数组添加到另一个数组 1234var array = ['a', 'b','c'];var nums = [1, 2, 3];array.push.apply(array, nums);array //["a", "b", "c", 1, 2, 3] 注：concat() 方法连接数组，不会改变原数组，而是创建一个新数组。而使用 push 是接受可变数量的参数的方式来添加元素。使用 apply 则可以连接两个数组。 2.与数组相关的内置函数联用 123var numbers = [7, 10, 2, 1, 11, 9];var max = Math.max.apply(null, numbers); max; //11 注：直接使用 max() 方法的写法为： Math.max(7, 10, 2, 1, 11, 9); bind() bind() 方法创建一个新的函数（称为绑定函数），在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。语法为： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 注：参数 thisArg ：当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。参数：arg1, arg2, …表示当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。 123456789var bin = function()&#123; console.log(this.x);&#125;var foo = &#123;x:10&#125;bin(); // undefinedvar func = bin.bind(foo); //创建一个新函数把 'this' 绑定到 foo 对象func(); // 10 新栗子 1234567891011121314this.num = 6;var test = &#123; num: 66, getNum: function() &#123; return this.num; &#125;&#125;;test.getNum(); // 返回 66var newTest = test.getNum;newTest(); // 返回 6, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到 test 对象var bindgetNum = newTest.bind(test);bindgetNum(); // 返回 66 是不是很神奇？ 123456789var newTest = test.getNum;newTest(); //上面这两行代码其实相当于：var newTest()&#123; return this.num;&#125;//所以 this 指向的是全局作用域，返回 6。 作用域 块级作用域 没有块级作用域！使用 {} 标记出来的代码块中声明的变量 num，是可以被 {} 外面访问到的。 函数作用域 字面意思，和c语言类似 全局作用域 我们不用 var 关键字，直接声明变量的话，那个变量就是全局变量，它的作用域就是全局作用域。 使用 windows 全局对象来声明，全局对象的属性也是全局变量。另外在所有的函数外部用 var 声明的变量也是全局变量，这是因为内层作用域可以访问外层作用域。 注： 内层作用域可以访问外层作用域，反之不行。 整个代码结构中只有函数可以限定作用域。 如果当前作用规则中有名字了, 就不考虑外面的同名变量。 作用域规则首先使用提升规则分析。 函数重名 123456789func();function func()&#123; console.log("Hello syl");&#125;func();function func()&#123; console.log("hi syl");&#125; 运行结果是 两遍 hi syl 相当于下面的函数覆盖了上面的函数然后执行了两遍 函数变量同名的时候： 123console.log(foo);function foo()&#123;&#125;var foo = 6; 当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略。所以上面的代码相当于： 123function foo()&#123;&#125;;console.log(foo);foo = 6; 控制台输出[Function: foo] 闭包 闭包是指函数可以使用函数之外定义的变量。 简单的闭包 在 JavaScript 中，使用全局变量是一个简单的闭包实例。比如： 12345var num = 3;//直接 num = 3也行function foo()&#123; console.log(num);&#125;foo(); //打印 3 复杂的闭包 12345678910function f1()&#123; var num1 = 6; function f2()&#123; var num2 = 7; return num2; &#125; return f2(); console.log(num1 + num2);&#125;f1() 在上述代码中函数 f2 能够访问到它外层的变量 num，但是 f1 是不能访问 f2 中的变量的，因此我们可以把 num2 作为 f2 的返回值，再把 f2 作为返回值就可以访问到了。 arguments对象 在函数代码中，使用特殊对象 arguments，无需明确指出参数名，我们就能访问它们。第一个参数是 arguments[0]，第二个参数是 arguments[1]，以此类推。比如： 123456function foo() &#123; console.log(arguments[0]); console.log(arguments[1]);&#125;foo(2,3);//打印 2 3 还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。来看一个遍历参数求和的例子： 1234567891011function add() &#123; var sum =0; for(var i=0; i&lt;arguments.length; i++)&#123; sum += arguments[i]; &#125; return sum;&#125;add(); // 0add(1); // 1add(1,2); // 3 add(1,2,3); // 6 Function对象 用 Function 对象创建函数的语法如下： 1var function_name = new Function(arg1, arg2, ..., argN, function_body) 注：每个参数都必须是字符串，function_body 是函数主体，也就是要执行的代码。 例子： 12var add = new Function("a","b","console.log(a+b);");add(2,5); //打印7 Function 对象的 length 属性 函数属于引用类型，所以它们也有属性和方法。length 属性声明了函数期望的参数个数。 例子： 12var add = new Function("a","b","console.log(a+b);");console.log(add.length); // 打印2 Function 对象的方法 Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码。 例子： 123var add = new Function("a","b","console.log(a+b);");add.valueOf();add.toString();]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记]]></title>
    <url>%2F2019%2F07%2F28%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript，通常缩写为 JS，是一种高级的，不进行预编译的，从上到下逐行执行的编程语言。 JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持 I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 基础 高级运算符 求余 x = y % 2 累加 让 a = 5 c = a++, 结果: c = 5 和 a = 6 c = ++a, 结果: c = 6 和 a = 6 JavaScript 的组成 ECMAScript：JavaScript 的语法标准。 DOM：JavaScript 操作网页上的元素的 API。 BOM：JavaScript 操作浏览器的部分功能的 API。 变量 动态类型 JavaScript 是一种“动态类型语言”，这意味着不同于其他一些语言(如 C、Java)，你不需要指定变量将包含什么数据类型（例如 number 或 string）,通通用 var 关键字声明就是了。 数组 操作数组 获取数组长度 使用length方法获取 利用分隔符将字符串转化为数组 使用split(&quot;x&quot;)方法 例如：&quot;1:2:3:4&quot;.split(&quot;:&quot;) // returns [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] 将数组转化为字符串 使用join(&quot;x&quot;)方法 例如：[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;].join(&quot;:&quot;); // returns &quot;1:2:3:4&quot; 注：我们同样可以使用 toString() 方法将数组转换为字符串，但是 join() 方法可以指定不同的分隔符，而 toString() 方法只能是逗号。 添加数组项 使用push()方法 删除数组项 使用pop()删除数组最后一个元素 unshift() 和 shift() 从功能上与 push() 和 pop() 完全相同，只是它们分别作用于数组的开始，而不是结尾。 字符串 操作字符串 连接字符串 通过 “+” 连接字符串 字符串转换 通过 toString 方法把数字转换成字符串 123 var myNum = 123;var myString = myNum.toString();typeof myString; 数值类型的 toString() ,可以携带一个参数,输出对应进制的值。比如： 123456var num = 16;console.log(num.toString()); //"16" 默认是10进制console.log(num.toString(10));//"16"console.log(num.toString(2)); //"10000"console.log(num.toString(8)); //"20"console.log(num.toString(16));//"10" 注：因为有的值没有 toString() 方法，所以需要用 String(),比如 null 和 undefined。 通过 Number对象把传递给它的字符串类型的数字转换为数字。 123var myString = '123';var myNum = Number(myString);typeof myNum; parseInt()把字符串转换成整数。 1234567891011121314var num1 = parseInt("12.3abc"); num1; //返回 12，如果第一个字符是数字会解析知道遇到非数字结束,只取整，不是约等于var num2 = parseInt("abc123"); num2; //返回 NaN，如果第一个字符不是数字或者符号就返回 NaNvar num3 = parseInt(""); num3; // 空字符串返回 NaN，但是 Number("")返回 0var num4 = parseInt("520");num4; //返回 520var num5 = parseInt("0xA"); num5; //返回 10 parseFloat()把字符串转换成浮点数。写法和parseInt()相似，主要有以下几个不同点： parseFloat不支持第二个参数，只能解析 10 进制数 如果解析的内容里只有整数，解析成整数 在字符串中查找子字符串并提取它 使用indexof(&quot;x&quot;)方法 最详细的写法是str.indexOf(searchValue, fromIndex); str 指的是我们需要查的较长的字符串，searchValue 表示我们指定的较小的字符串，fromIndex 表示调用该方法的字符串中开始查找的位置，是一个可选的任意整数值，也可以不写，默认是 0 表示从头开始查，fromIndex &lt; 0 和 fromIndex = 0 是一样的效果，表示从头开始查找整个字符串。 12"Blue Sky".indexOf("Blue"); // returns 0"Blue Sky".indexOf("", 0); // returns 0 使用slice(strat，end)方法 第一个参数 start 是开始提取的字符位置，第二个参数 end 是提取的最后一个字符的后一个位置。 例如：&quot;Blue Sky&quot;.slice(0,3); // returns &quot;Blu&quot; 还可以省略第一个参数 &quot;Blue Sky&quot;.slice(2); // returns &quot;ue Sky&quot; 转换大小写 字符串方法 toLowerCase() 和toUpperCase() 字符串并将所有字符分别转换为小写或大写。 替换字符串 使用replace()方法 12var string = "I like study";string.replace("study","sleep"); // returns "I like sleep" 函数 函数声明和函数表达式的区别 函数声明 12345//此处的代码执行没有问题，JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面。 f(2,3); function f(a,b) &#123; console.log(a+b); &#125; 函数表达式 1234567//报错：f is not a function//这是因为函数表达式，如同定义其它基本类型的变量一样，只在执行到某一句时也会对其进行解析 f(2,3); var f = function(a,b)&#123; console.log(a+b); &#125; 在 JavaScript 中没有重载 12345678function f(a,b) &#123; return a + b;&#125;function f(a,b,c) &#123; return a + b + c;&#125;var result = f(5,6); result;// returns NaN 上述代码中三个参数的 f 把两个参数的 f 覆盖，调用的是三个参数的 f，最后执行结果为 NaN。而不是其他语言中的 5。 匿名函数 匿名函数就是没有命名的函数，一般用在绑定事件的时候。 12345var myButton = document.querySelector('button');myButton.onclick = function() &#123; alert('hello');&#125; 注：将匿名函数分配为变量的值，也就是我们前面所讲的函数表达式创建函数。一般来说，创建功能，我们使用函数声明来创建函数。使用匿名函数来运行负载的代码以响应事件触发（如点击按钮） ，使用事件处理程序。 自调用函数 匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行。 123(function () &#123; alert('hello');&#125;)(); 输入函数 prompt(&quot;请输入&quot;) 输出函数 document.write() 对象 什么是对象？男朋友？女朋友？这是你以为的对象？当然这可能是我们大多数人生活中对于对象最直观的理解。 而在 JavaScript 中所有事物都是对象：字符串，数组，日期等等。我们甚至可以自己创建对象，将相关的函数和变量封装打包成便捷的数据容器。另外值得注意的是 JavaScript 是一门基于对象的语言。 在 JavaScript 中对象是拥有属性和方法的数据。 属性和方法 属性是与对象相关的值，也可以理解为特征。方法是能够在对象上执行的动作，也可以理解为行为。 举个例子：一辆汽车就是现实生活中的对象，它的名字，它的颜色，它的价格等特征就是汽车对象的属性。它能够启动，驾驶，加速，刹车等行为就是汽车对象的方法。 JSON JSON 是一种纯数据格式,它只包含属性,没有方法。 JSON 的属性必须通过双引号引起来。 JSON 要求有两头的 { } 来使其合法。 尽管 JSON 是 JavaScript 的一个子集，但 JSON 是独立于语言的文本格式，并且采用了类似于 C 语言家族的一些习惯。 JSON 数据格式与语言无关，脱胎于 JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。 内置对象 Array对象 常用属性 length 获取数组长度 常用方法 concat()方法用于连接两个或多个数组，并返回结果。栗子: 1234var a = [1,2,3];var b = [4,5,6];var c =["one","two","three"];console.log(a.concat(b,c)); //打印结果为：[1, 2, 3, 4, 5, 6, "one", "two", "three"] join()方法将数组转换成字符串 pop()方法删除并返回数组的最后一个元素 push()方法向数组的末尾添加一个或更多元素，并返回新的长度。 everse() 方法颠倒数组的顺序。 shift() 方法删除并返回数组的第一个元素。 unshift() 方法向数组的开头添加一个或更多元素，并返回新的长度。 slice() 方法从某个已有的数组返回选定的元素。 123x.slice(start,end);//strat 值是必需的，规定从何处开始选取。//end 值可选，规定从何处结束选取，如果没有设置，默认为从 start 开始选取到数组后面的所有元素。 splice(start,deleteCount,options) 方法删除或替换当前数组的某些项目。 start 值是必需的，规定删除或替换项目的位置 deleteCount 值是必需的，规定要删除的项目数量，如果设置为 0，则不会删除项目。 options 值是可选的，规定要替换的新项目 和 slice() 方法不同的是 splice() 方法会修改数组。 123var a = [1,2,3,4,5,6];a.splice(2,2,"abc");a; // 最终 a 数组变成了[1, 2, "abc", 5, 6] toString() 方法把数组转换为字符串，并返回结果。 sort()方法排序 array.sort(sortfunction) 两个小例子 123456789101112131415var arr3 = [1,22,44,6,55,5,2,4,66]; document.write(arr3 + "&lt;br /&gt;"); document.write(arr3.sort() + "&lt;br /&gt;" + "&lt;br /&gt;");输出//1,22,44,6,55,5,2,4,66//1,2,22,4,44,5,55,6,66 function sortNum1(a,b)&#123; return a - b;//从小到大排序 &#125; var arr4 = [1,22,44,6,55,5,2,4,66]; document.write(arr4 + "&lt;br /&gt;"); document.write(arr4.sort(sortNum1) + "&lt;br /&gt;" + "&lt;br /&gt;");输出//1,22,44,6,55,5,2,4,66//1,2,4,5,6,22,44,55,66 显然是回调函数做的手脚，那么原理是什么呢？ 回调函数的参数要有两个：第一个参数的元素肯定在第二个参数的元素前面!!! 这个方法的排序是看回调函数的返回值： 如果返回值大于 0，则位置互换。 如果返回值小于 0，则位置不变。 String对象 常用属性：length。获取字符串的长度。 常用方法 charAt(index)方法获取指定位置处字符。 123var str = "Hello world!";document.write(str.charAt(2));//以上代码输出为 l charCodeAt(index) 方法获取指定位置处字符的 Unicode 编码。 123var str = "Hello world!";document.write(str.charCodeAt(2));//以上代码输出为 l08 concat() 方法，连接字符串,等效于 “+”，“+” 更常用。与数组中的 concat() 方法相似。 slice() 方法，提取字符串的片断，并在新的字符串中返回被提取的部分（字符串章节有详细介绍，这里不过多的赘述，下面的类似情况同样处理）。 indexOf() 方法，检索字符串。 toString() 方法，返回字符串。 toLowerCase() 方法，把字符串转换为小写。 toUpperCase() 方法，把字符串转换为大写。 replace() 方法，替换字符串中的某部分。 split() 方法，把字符串分割为字符串数组。 Date对象 Date()：返回当日的日期和时间。（输出是中国标准时间） getDate()：从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay()：从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth():从 Date 对象返回月份 (0 ~ 11)。 getFullYear():从 Date 对象以四位数字返回年份。 getHours():返回 Date 对象的小时 (0 ~ 23)。 getMinutes():返回 Date 对象的分钟 (0 ~ 59)。 getSeconds():返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds():返回 Date 对象的毫秒(0 ~ 999)。 Math对象 常用属性： E ：返回常数 e (2.718281828…)。 LN2 ：返回 2 的自然对数 (ln 2)。 LN10 ：返回 10 的自然对数 (ln 10)。 LOG2E ：返回以 2 为底的 e 的对数 (log2e)。 LOG10E ：返回以 10 为底的 e 的对数 (log10e)。 PI ：返回π（3.1415926535…)。 SQRT1_2 ：返回 1/2 的平方根。 SQRT2 ：返回 2 的平方根。 常用方法 abs(x) ：返回 x 的绝对值。 round(x) ：返回 x 四舍五入后的值。 sqrt(x) ：返回 x 的平方根。 ceil(x) ：返回大于等于 x 的最小整数。 floor(x) ：返回小于等于 x 的最大整数。 sin(x) ：返回 x 的正弦。 cos(x) ：返回 x 的余弦。 tan(x) ：返回 x 的正切。 acos(x) ：返回 x 的反余弦值（余弦值等于 x 的角度），用弧度表示。 asin(x) ：返回 x 的反正弦值。 atan(x) ：返回 x 的反正切值。 exp(x) ：返回 e 的 x 次幂 (e^x)。 pow(n, m) ：返回 n 的 m 次幂 (nm)。 log(x) ：返回 x 的自然对数 (ln x)。 max(a, b) ：返回 a, b 中较大的数。 min(a, b) ：返回 a, b 中较小的数。 random() ：返回大于 0 小于 1 的一个随机数。 创建对象 通过对象字面量来创建 12345678var student = &#123; name: 'zhangsan', age: 18, gender : 'male', sayHi: function () &#123; console.log("hi,my name is "+this.name); &#125;&#125;; 通过 new Object() 创建对象 1234567var student = new Object(); student.name = 'zhangsan', student.age = 18, student.gender = 'male', student.sayHi = function () &#123; console.log("hi,my name is "+this.name); &#125; 通过函数创建 1234567891011function createStudent(name, age, gender) &#123; var student = new Object(); student.name = name; student.age = age; student.gender = gender; student.sayHi = function()&#123; console.log("hi,my name is "+this.name); &#125; return student;&#125;var s1 = createStudent('zhangsan', 18, 'male'); 构造函数 123456789function Student(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; this.sayHi = function()&#123; console.log("hi,my name is "+this.name); &#125;&#125;var s1 = new Student('zhangsan', 18, 'male'); 补充： new关键字 构造函数，是一种特殊的函数。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与 new 运算符一起使用在创建对象的语句中。这里有需要特别注意的几点： 构造函数用于创建一类对象，首字母要大写。 内部使用 this 关键字给对象添加成员。 使用 new 关键字调用对象构造函数。 this关键字 this到底指向什么？ 其实很简单：谁调用this，它就是谁 函数在定义的时候 this 是不确定的，只有在调用的时候才可以确定 一般函数直接执行，内部 this 指向全局 window。 函数作为一个对象的方法，被该对象所调用，那么 this 指向的是该对象。 构造函数中的 this，始终是 new 的当前对象。 遍历属性 通过 for…in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作） 1234567891011&lt;script&gt; var student = &#123; name: 'zhangsan', age: 18, gender: 'male' &#125;; for(var key in student) &#123; console.log(key); console.log(student[key]); &#125; &lt;/script&gt; 注：key 是一个变量,这个变量中存储的是该对象的所有的属性的名字。 删除对象的属性 使用delete删除 1234567var student = &#123; name: 'zhangsan', age: 18, gender: 'male'&#125;;student.name; // "zhangsan"delete student.name;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习笔记(一)]]></title>
    <url>%2F2019%2F07%2F24%2FNode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js适用场景 Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。 比如：聊天室，博客系统，考试系统等。 全局对象 在 JavaScript 中全局对象通常是 window，而在 Node.js 中全局对象是 globa，所有全局变量（除了 global 本身以外）都是 global 对象的属性，我们可以直接访问到 global 的属性 全局变量 按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量 全局对象的属性 隐式定义的变量（未定义直接赋值的变量） 当你定义一个全局变量的时候，这个变量同时也会成为全局对象的属性，反之亦然。在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。定义变量一定要使用 var 关键字，因为全局变量会污染命名空间。 常见全局变量和全局函数 __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。 __dirname，表示当前执行脚本所在的目录。 setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb),只执行一次函数。 require方法–创建hello world Node中的JavaScript可以具备文件操作能力，得益于丰富的API。 引入核心模块fs，调用相应的API即可实现 黑马程序员实验楼12345678910111213var fs = require('fs')//用require方法创建实例fs.writeFile('./hello.md','写入一段文本')var http = require('http')var server = http.createServer()server.on('request',function(request,response)&#123; console.log('收到请求:'+request.url) response.write('hello') response.end()&#125;)server.listen(3000,function()&#123; console.log('启动咯')&#125;)123456var http = require('http');http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); response.end('hello world');&#125;).listen(8080);console.log('开启咯') http.createServer([requestListener]) 其中requestListener 请求函数是一个自动添加到 ‘request’ 事件的函数。函数传递有两个参数：request 请求对象 和 response 响应对象。 response 对象常用的方法有： response.writeHead(statusCode[, statusMessage][, headers])。表示向请求发送响应头。 response.write() 发送一块响应主体，也就是说用来给客户端发送响应数据。可以直接写文本信息，也可以写我们的 html 代码，注意要设置 Content-Type 的值 。write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待。 response.end() 此方法向服务器发出信号，表示已发送所有响应头和主体，该服务器应该视为此消息完成。必须在每个响应上调用方法 response.end()。 request对象的常用方法： request.url 获取请求路径，获取到的是端口号之后的那一部分路径,也就是说所有的 url 都是以 / 开头的，判断路径处理响应。 request.socket.localAddress 获取 ip 地址。 request.socket.remotePort 获取源端口。 Node.js包 用于管理多个模块及其依赖关系，可以对多个模块进行封装，包的根目录必须包含 package.json 文件，package.json 文件是 CommonJS 规范用于描述包的文件，符合 CommonJS 规范的 package.json 文件一般包含以下字段： name：包名。包名是唯一的，只能包含小写字母、数字和下划线。 version：包版本号。 description：包说明。 keywords：关键字数组，用于搜索。 homepage：项目主页。 bugs：提交 bug 的地址。 license：许可证。 maintainers：维护者数组。 contributors：贡献者数组。 repositories：项目仓库托管地址数组。 dependencies：包依赖。这个属性十分重要，NPM会通过这个属性，帮你自动加载依赖的包 packae.json包示例 123456789101112131415161718192021222324252627282930313233343536&#123; "name": "shiyanlou", "description": "Shiyanlou test package.", "version": "0.1.0", "keywords": [ "shiyanlou", "nodejs" ], "maintainers": [&#123; "name": "test", "email": "test@shiyanlou.com" &#125;], "contributors": [&#123; "name": "test", "web": "http://www.shiyanlou.com/" &#125;], "bugs": &#123; "mail": "test@shiyanlou.com", "web": "http://www.shiyanlou.com/" &#125;, "licenses": [&#123; "type": "Apache License v2", "url": "http://www.apache.org/licenses/apache2.html" &#125;], "repositories": [&#123; "type": "git", "url": "http://github.com/test/test.git" &#125;], "dependencies": &#123; "webkit": "1.2", "ssl": &#123; "gnutls": ["1.0", "2.0"], "openssl": "0.9.8" &#125; &#125;&#125; 注： package.json 文件可以自己手动编辑，还可以通过 npm init 命令进行生成。你可以自己尝试在终端中输入 npm init 命令来生成一个包含 package.json 文件的包。直接输入 npm init --yes 跳过回答问题步骤，直接生成默认值的 package.json 文件。 安装包 npm install express 更新包 npm update express 删除包 npm uninstall express Node.js模块 在 JavaScript 中，我们通常把 JavaScript 代码分为几个 js 文件，然后在浏览器中将这些 js 文件合并运行，但是在 Node.js 中，是通过以模块为单位来划分所有功能的，每一个模块为一个 js 文件，每一个模块中定义的全局变量和函数的作用范围也被限定在这个模块之内，只有使用 exports 对象才能传递到外部使用。 ▶1.js 1234function foo()&#123; console.log('hello');&#125;module.exports.foo = foo;//用module.exports导出,也可以直接exports导出 ▶2.js 12var hello = require('./1.js');hello.foo(); require 加载模块，以’/’ 为前缀的模块是文件的绝对路径。’./’ 为前缀的模块是相对于调用 require() 的文件的，上面的例子中 index.js 和 myModule.js 是在同一个目录下（project 目录）。当没有以 ‘/’、’./’ 或 ‘…/’ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。 module.exports 和 exports 的区别 每次导出接口成员的时候都通过 module.exports.xxx = xxx 的方式很麻烦。所以，Node.js 为了简化你的操作，专门提供了一个变量：exports 等于 module.exports。也就是说在模块中还有这么一句代码： var exports = module.exports; 让我们看一下它们 1234567a = &#123; b:3&#125;console.log(a);console.log(module.exports);console.log(exports == module.exports)console.log(exports === module.exports) 运行结果： 1234567exports = &#123; b:3&#125;console.log(exports);console.log(module.exports);console.log(exports == module.exports)console.log(exports === module.exports) 运行结果： 也就是说给 exports 赋值会断开和 module.exports 之间的引用，同样的给 module.exports 重新赋值也会断开它们之间的引用。但是最终导出的是 module.exports。而如果给其他变量赋值则没有对exports 和 module.exports之间的引用造成改变。即module.exports才是真正的接口，exports只不过是它的一个辅助工具。最终返回给调用的是module.exports而不是exports 总结： require 得到的是 module.exports 导出的值，导出多个成员可以用 module.exports 和 exports,导出单个成员只能用 module.exports。 Node.js函数 在 JavaScript 中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后把函数作为变量在另一个函数中传递，也可以在传递参数的地方直接定义函数。 1234567function sayHi(value)&#123; console.log(value);&#125;function execute(someFunction,value)&#123; someFunction(value);&#125;execute(sayHi,'hi'); 匿名函数 123var fun = function()&#123;&#125; 箭头函数 1234567891011(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）// 当只有一个参数时，圆括号是可选的(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125; 示例： 12345var fun = function()&#123; console.log('hello syl');&#125;//上面的匿名函数可以用箭头函数改写为下面的var fun = () =&gt; console.log('hello syl'); Node.js 异步编程 Node.js 异步编程的直接体现就是回调。回调函数在完成任务后就会被调用，Node.js 使用了大量的回调函数，Node.js 所有 API 都支持回调函数。回调函数一般作为函数的最后一个参数出现。 阻塞代码 1234var fs = require('fs');var data = fs.readFileSync('1.txt');console.log(data.toString());console.log('end') 运行结果： 非阻塞代码 123456var fs = require('fs');fs.readFile('1.txt',function (err,data)&#123; if(err) return console.error(err); console.log(data.toString());&#125;);console.log('end'); 运行结果： 第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 异步打开文件 fs.open(path, flags[, mode], callback) 参数说明： path:文件的路径 flags：文件打开的行为。 mode：设置文件模式(权限)，文件创建默认权限为 0o666（可读写）。mode 设置文件模式（权限和粘滞位），但仅限于创建文件的情况。在 Windows 上，只能操作写权限。 callback：回调函数，带有两个参数如：callback(err, fd)。 flags 参数可以是以下值： ‘a’ - 打开文件用于追加。如果文件不存在，则创建该文件。 ‘ax’ - 与 ‘a’ 相似，但如果路径存在则失败。 ‘a+’ - 打开文件用于读取和追加。如果文件不存在，则创建该文件。 ‘ax+’ - 与 ‘a+’ 相似，但如果路径存在则失败。 ‘as’ - 以同步模式打开文件用于追加。如果文件不存在，则创建该文件。 ‘as+’ - 以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。 ‘r’ - 打开文件用于读取。如果文件不存在，则会发生异常。 ‘r+’ - 打开文件用于读取和写入。如果文件不存在，则会发生异常。 ‘rs+’ - 以同步模式打开文件用于读取和写入。指示操作系统绕开本地文件系统缓存。这对于在 NFS 挂载上打开文件非常有用，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。这不会将 fs.open() 或 fsPromises.open() 转换为同步的阻塞调用。 如果需要同步操作，则应使用 fs.openSync() 之类的操作。 ‘w’ - 打开文件用于写入。创建文件（如果它不存在）或截断文件（如果存在）。 ‘wx’ - 与 ‘w’ 相似，但如果路径存在则失败。 ‘w+’ - 打开文件用于读取和写入。创建文件（如果它不存在）或截断文件（如果存在）。 ‘wx+’ - 与 ‘w+’ 相似，但如果路径存在则失败。 异步关闭文件 fs.close(fd, callback) 参数说明： fd：通过 fs.open() 方法返回的文件描述符。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 123456789101112131415var fs = require("fs");// 异步打开文件fs.open('test.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); //异步关闭文件 fs.close(fd, function(err)&#123;//特别注意：fs.close是包在fs.open中参数之一的回调函数中的，而且它们的参数形式不同。 fs.open是文件路径名,fs.close是传入的回调函数的fd参数。 if (err)&#123; console.log(err); &#125; console.log("文件关闭成功"); &#125;);&#125;); 读写文件 **异步读取文件的语法格式为： fs.read(fd, buffer, offset, length, position, callback) 参数说明： fd: 通过 fs.open() 方法返回的文件描述符。//不能变成路径！ buffer:是数据写入的缓冲区。 通常用var buf= Buffer.alloc(1024)创建1024字节的缓冲区然后传参 offset:是缓冲区中开始写入的偏移量。一般它的值我们写为 0。 length:是一个整数，指定要读取的字节数。 position:指定从文件中开始读取的位置。 如果 position 为 null，则从当前文件位置读取数据，并更新文件位置。 callback:回调函数，有三个参数 err, bytesRead, buffer。err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 示例： 1234567891011121314151617181920212223242526272829var fs = require("fs");// 异步打开文件fs.open('test.txt', 'r+', function(err, fd) &#123; if(err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); console.log("准备读取文件："); // 创建一个大小为 1024 字节的缓存区 var buf = Buffer.alloc(1024); // 异步读取文件 fs.read(fd, buf, 0, buf.length, 0, function(err, bytes, buf) &#123; if(err) &#123; console.log(err); &#125; console.log(bytes + "字节被读取"); // 仅输出读取的字节 if(bytes &gt; 0) &#123; console.log(buf.slice(0, bytes).toString()); &#125; // 异步关闭文件 fs.close(fd, function(err) &#123; if(err) &#123; console.log(err); &#125; console.log("文件关闭成功"); &#125;); &#125;);&#125;); 异步写入文件的语法格式为： fs.write(fd, buffer, offset, length, position, callback) 参数说明： fd：从指定的文件写入数据。 buffer：是数据写入的缓冲区。 offset：指定要写入的 buffer 部分。 length：是一个整数，指定要写入的字节数。 position 指定应该写入此数据的文件开头的偏移量。 如果 typeof position !== ‘number’，则从当前位置写入数据。 callback：回调有三个参数 (err, bytesWritten, buffer)，其中 bytesWritten 指定从 buffer 写入的字节数。 12345678910111213141516171819202122232425262728var fs = require('fs');// 异步打开文件fs.open('./test.txt', 'a', function(err, fd) &#123; if(err) &#123; return console.error(err); &#125; console.log("文件打开成功！"); console.log("准备写入文件："); //新写入内容为 hello world var buffer = Buffer.from(new String(' hello world')); // 异步写入文件 fs.write(fd, buffer, 0, 12, 0, function(err, bytes, buffer) &#123;//0，12这两个参数 一个是buffer字符串位于开头的偏移量 一个是总共要写入的字符数 它们的和 不能超过buffer的总长度 if (err) &#123; throw err; &#125; console.log('写入成功'); // 打印出buffer中存入的数据 console.log(bytes + "字节被写入"); console.log(buffer.slice(0, bytes).toString()); // 异步关闭文件 fs.close(fd, function(err) &#123; if(err) &#123; console.log(err); &#125; console.log("文件关闭成功"); &#125;); &#125;);&#125;); 或 fs.write(fd, string[, position[, encoding]], callback) 参数说明： fd：从指定的文件写入数据。 string:写入的数据，如果不是字符串，则该值将被强制转换为字符串。 position 指定应该写入此数据的文件开头的偏移量。 如果 typeof position !== ‘number’，则从当前位置写入数据。 encoding：指定字符串的编码，默认为 ‘utf8’。 callback：回调有三个参数 (err, written, string)，其中 written 指定字符串中已写入文件的字节数。 写入的字节数与字符串的字符数是不同的。 123456789101112131415var fs = require('fs')fs.open('./1.txt','a',function(err,fd)&#123; if(err) console.error(err) var data = 'hello' fs.write(fd,data,0,'utf-8',function(err,bytes,Buffer)&#123; if(err) console.error(err) console.log(Buffer) &#125;) fs.close(fd,function(err)&#123; if(err) console.error(err) &#125;)&#125;) 以上方法都是基于fs.open()函数的，那么有没有简单粗暴点的函数呢？ Yeap！ fs.readFile(path,[options], callback)闪亮登场 法一： 123456var fs = require('fs')fs.readFile('./1.txt',function(err,data)&#123; if(err) console.log(err) console.log(data.toString())&#125;) 法二： 1234567var fs = require('fs');fs.readFile('./test.txt', 'utf-8', function(err, data) &#123;//加上编码方式 if (err) &#123; throw err; &#125; console.log(data);&#125;); fs.writeFile(file, data,[options], callback) 参数说明： file：文件名或文件描述符。 data：要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。 options：该参数是一个对象，包含 {encoding, mode, flag}。encoding 默认值为：‘utf8’, mode 默认值为 0o666 ，flag 默认为 ‘w’。 callback：回调函数。 示例： 123456789101112131415var fs = require('fs');// 传递了追加参数 &#123; 'flag': 'a' &#125;fs.writeFile('./test.txt', '我是新加的内容', &#123; 'flag': 'a' &#125;, function(err) &#123; if (err) &#123; throw err; &#125; console.log('Saved.'); // 写入成功后读取测试 fs.readFile('./test.txt', 'utf-8', function(err, data) &#123; if (err) &#123; throw err; &#125; console.log(data); &#125;);&#125;); 专门的异步追加函数fs.appendFile(path, data[, options], callback) 1234fs.appendFile('message.txt', '追加的数据', (err) =&gt; &#123; if (err) throw err; console.log('数据已追加到文件');&#125;); 如果 options 是字符串，则它指定字符编码： fs.appendFile('message.txt', '追加的数据', 'utf8', callback); 截取文件（将文件只保留前n个字节） fs.ftruncate(fd[, len], callback) 参数说明： fd：通过 fs.open() 方法返回的文件描述符。 len：文件内容截取的长度，默认为 0。 callback：除了可能的异常，完成回调没有其他参数。 1234567891011var fs = require('fs')fs.open('./1.txt','r+',function(err,fd)&#123;//注意这里必须是r+属性，否则无法截取 if(err) throw err fs.ftruncate(fd,3,function(err)&#123; fs.readFile('./1.txt',function(err,data)&#123; console.log(data.toString()) &#125;) &#125;)&#125;) 删除文件 fs.unlink(path, callback) 参数说明： path:文件路径。 callback: 除了可能的异常，完成回调没有其他参数。 修改文件名 fs.rename(oldPath, newPath, callback) 参数说明： oldPath:原来的文件名字。 newPath：新的文件名字。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 目录操作 新建目录 fs.mkdir(path[, options], callback) 参数说明： path：文件路径(名)。 options：有两个参数。recursive 表示是否以递归的方式创建目录，默认为 false。mode 设置目录权限，Windows 上不支持。默认为 0o777。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 读取目录 fs.readdir(path[, options], callback) 参数说明： path：文件路径。 options：有两个参数 encoding，withFileTypes。encoding 默认值为 ‘utf8’，withFileTypes 默认值为 false。 callback - 回调函数，回调函数带有两个参数 err, files。err 为错误信息，files 为目录下的文件数组列表。 删除目录 fs.rmdir(path, callback) Node.js事件 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。比如：fs.readStream 打开文件时会发出一个事件。可以通过 require(“events”); 获得 event 模块。通常，事件名采用“驼峰式”(即单词首字母大写，其他字母小写)命名方式。 EventEmitter 所有能触发事件的对象都是 EventEmitter 类的实例。这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 ** EventEmitter类获取** 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 添加监听器 emitter.on(eventName, listener) 使用 emitter.on(eventName, listener) 方法为指定事件注册一个监听器。添加 listener 函数到名为 eventName 的事件的监听器数组的末尾。 别名 emitter.addListener(eventName, listener) 注意，这种注册监听器的方法将监听器一直保留在内存中 参数说明： eventName：事件名称，string 类型。 listener：回调函数。 示例 123456789101112//引入 events 模块var events = require('events');// 创建 emitter 对象var emitter = new events.EventEmitter();//为 connection 事件注册一个监听器emitter.on('connection', function() &#123; console.log('已连接');&#125;);//一秒后调用监听器setTimeout(function() &#123; emitter.emit('connection');&#125;, 1000); 运行结果： 其原理是emitter对象给connection事件注册了监听器，用setTimeout函数1000毫秒后向emitter对象发送事件connection，此时调用它的监听器。emit方法就是发送事件的。 使用emitter.emit(eventName[, ...args])按照监听器注册的顺序，同步地调用每个注册到名为eventName的事件的监听器，并传入提供的参数。如果事件有注册监听返回 true，否则返回 false。 参数说明： eventName ：事件名称 args：传递的参数，多个，类型为任意。 默认情况下，事件监听器会按照添加的顺序依次调用。emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。 例如在setTimeout前添加，emitter.prependListener('connection',() =&gt;console.log('hh'));，将会先打印hh,再打印已连接。 eventEmitter.once(eventName, listener) 此可以注册最多可调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用。 而emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。 移除监听器 emitter.removeListener(eventName, listener) 参数说明： eventName 事件名称 listener 监听器也就是回调函数名称。 注：removeListener() 最多只会从监听器数组中移除一个监听器。我们可以多次调用 removeListener() 的方式来一个个的移除我们需要移除掉的监听器。 emitter.off(eventName, listener)是emitter.removeListener()的别名 emitter.removeAllListeners([eventName]) 使用 emitter.removeAllListeners([eventName]) 移除全部监听器或指定的 eventName 事件的监听器。 设置监听器最大绑定数 emitter.setMaxListeners(n) 默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告，这有助于我们发现内存泄露。显然实际编码中并不是所有的事件都要限制 10 个监听器。 emitter.setMaxListeners() 方法可以为指定的 EventEmitter 实例修改限制。当值设为 Infinity（或 0）表示不限制监听器的数量。 查看事件绑定的监听器个数 emitter.listenerCount(eventName) error事件 当 EventEmitter 实例出错时，应该触发 ‘error’ 事件。 如果没有为 ‘error’ 事件注册监听器，则当 ‘error’ 事件触发时，会抛出错误、打印堆栈跟踪、并退出 Node.js 进程。 通常我们要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 123456var events = require('events');var emitter = new events.EventEmitter();emitter.on('error',(err)=&gt;&#123; console.error('错误');&#125;);emitter.emit('error'); Node.js框架—Express框架 可以通过 Express 可以快速地搭建一个完整功能的网站。使用框架的目的就是让我们更加专注于业务，而不是底层细节。 第一个示例 12345678910var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);app.listen(3000, function () &#123; console.log("服务器启动了");&#125;); 路由 app.method(path, handler) 路由用于确定应用程序如何响应客户端请求，包含一个 URI（路径）和一个特定的 HTTP 请求方法（GET、POST 等）。 注：app 是 express 的实例，method 是指 HTTP 请求方法（GET、POST 等），path 是指服务器上的路径，handler 是指路由匹配时执行的函数。 栗子 1234567891011121314151617181920var express = require('express');var app = express();// GET 请求app.get('/', function (req, res) &#123; console.log("GET 请求"); res.send('Hello，我是GET请求');&#125;)// POST 请求app.post('/', function (req, res) &#123; console.log("POST 请求"); res.send('Hello，我是 POST 请求');&#125;)// /index 响应index页面 GET 请求app.get('/index', function (req, res) &#123; console.log("/响应index页面 GET 请求"); res.send('Hello，我是 index 页面 GET 请求');&#125;) 静态文件 公开public目录，然后访问其中的资源 app.use('/public/', express.static('./public/')) 或者 123456789101112var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res) &#123; res.send('Hello World');&#125;)app.listen(8080, function () &#123; console.log("服务器启动了");&#125;); Express 框架处理POST请求 1.js1.html1234567891011121314151617181920212223var express = require('express')var app = express()var bodyParser = require('body-parser') //创建 application/x-www-form-urlencoded 解析var urlencodedParser = bodyParser.urlencoded(&#123;extended: false&#125;)app.get('/', function (req, res) &#123; //传送指定路径的文件 -会自动根据文件extension设定Content-Type //也可以用前面的 art-template 模板引擎 //必须有 res.sendFile( __dirname + "/" + "1.html" );&#125;)//获取 URL编码的请求体app.post('/post_test',urlencodedParser,function(req,res)&#123; var response = &#123; "stuNum":req.body.stuNum, "stuNam":req.body.stuNam &#125; console.log(response) res.end(JSON.stringify(response))&#125;)app.listen('8080',function()&#123; console.log('start')&#125;)1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/post_test" method="POST"&gt; 学号: &lt;input type="text" name="stuNum"&gt;&lt;br /&gt; 姓名: &lt;input type="text" name="stuNam"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这里用到了body-parser这个HTTP请求体解析中间件，用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体 bodyParser.json(options): 解析json数据 bodyParser.raw(options): 解析二进制格式(Buffer流数据) bodyParser.text(options): 解析文本数据 bodyParser.urlencoded(options): 解析UTF-8的编码的数据。 option可选对象: bodyParser.json()bodyParser.raw()bodyParser.text()bodyParser.urlencoded() inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ reviver - 传递给JSON.parse()方法的第二个参数，详见JSON.parse() strict - 设置为true时，仅会解析Array和Object两种格式；设置为false会解析所有JSON.parse支持的格式。默认为true type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/json。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持 inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持 defaultCharset - 如果Content-Type后没有指定编码时，使用此编码。默认为’utf-8’ inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持 extended - 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ parameterLimit - 用于设置URL编码值的最大数据。默认为1000 type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海边出游&&日式烧烤🔞]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B5%B7%E8%BE%B9%E5%87%BA%E6%B8%B8and%E6%97%A5%E5%BC%8F%E7%83%A7%E7%83%A4%2F</url>
    <content type="text"><![CDATA[输入密码叭~ Incorrect Password! No content to display! U2FsdGVkX1+3JnxrQN1DzRX0B/NMG3FkkF4nT+1Tly7/1TmG29sgwn3pPMpzsDbvnvKoLU1LF9cB18w1BDNz2DRm2DlGiWabayvTem+FOkHLTnJErMJ1sBq1eL2HxeWxs+/7hyCVCF3LlTkfxPgfpUX6XGJCaCBdxaWplQin3HJFrw5SYqdoFiBktamE6NoPAaiiNTLnWHzVdiUFekZRa/oIp9LR3xg5F+Q0BtVThq7S2o8cKnUOog8WkO3N+YK2UMT0rWxqiGmD1Ro1ozXioVxk4s+QHvFn5sS2+BdvYd+4kfSYdX8ycOaJe2NmJfO+7aF8P8GQKx3CD1fv/9ZhIr3wlJseR+gs/N10+migBwmAhnU0mtPUgyeyw8iyBd4Y4TCl6ojSlYHmLZ4KqXycoVT/MQQstAnYh87ANss6iuxCJ+x8tYciz2n1816d6KiH3P4+VA7bTBQHW5u6wALfNY7aht8VqkCyXNcRt8vwOShHUi4tJj4OHA9BbJK6PbbsRCaStA/zUtRcMU3tgILoZ0HPohkKDVPvZYSc3KDh5CmP0PsKXRfNpJk0a5tcCsUWBMmx+ylQS2pEXZ5RVektLLjynBvXlekpuTLXFe6b8fd8F3beUsjFW3+yYBqDPgBIdscnx+w4gFbsZtxohqWFTGLRjxxkmaG7wJXnNvzp+Xh0bBYV55axtNNaBxxVQlnGtuTEHoQT+tjp4UA9AIqUuFUth3Nugghv6CpPwDifJr31dwIZTzNyQNlVSAUQvTvP3OgCvNQf53H466yFo5Waq06EpgSWRiYOIIsdR87eO45ROkUKobkrngliM7ZJNvEWNzA9RlkYnsr+xqYlR2k7MQn+ZqMkZVq9wpYkjNPUgsWDra0gkb7vN1jO85XtlLFGtjqUm5f+tctSz+OPd7eRNNTJpVR52X5U2PMopwbZ4ezgfjvP5Ldl9iNhBhy/NDBgashGKZz3DJ+46Rqm53pOOOenu2aGjSmDGeKnq8s6Wn91Z4GQAG1Y4ejTjMmTyH19t7TbHSqpBh6ojjjpCDh+YYP8621nmq/4EeYb9vwf8WdL9CouggWiI9UxBIdFqX/+FoPETc7pw/E6pwhwWvDLZzTSoTaH39ruVd5qjF3OoG+KeXXrBaZ527g51nbcqXYIU2ojCAeShbQlah2uWq3FwFoUABFt7b3sGSl1HrJDsqxWgEFa8/x0uvz8Rk9nynrvgyESnj+4mM8S0W2BIKfO43pDBsaJl3NuEKbf8Wwnblvgl81NHdM+h4CyJwK0IZHzd8vTq18Enu9MTyjsSEGpN50aaS1I0UGdj6prQVVElfuf8k2l+aCQr1stnvSdGxm5yMAlmaNUihxlmfqdTiAn5Wx3eC+M6uBDGSChud9DNZdWY343H356tlXPHp3wfzUhVembWGW1E52HHT4iZCYaMVAIpLRPUK0fvKpN/0c4Q25FxGmVl20IGjfWZ5q264RYj4s2KW55YOg0GQfX/fremB+MLLmNNgjyNUKaO+5kitDtYkKwxUIYCMBGPf5Ehe10tmZ2mif8BlvSJBddNodOwv/aUIeECIjBqtkGHhUHY0jv1oAN5YD7aOZr80yQyZFLjtSy6x+fnnYnnWnVDK8scnLVhPbL5A/+9uNC7pkZH+qNnS5gDFjnYE6e1dxWGl1XgK+IyV/sGNa/4/dpqyMBLGe0KkhtcOITlefesLQZgfZkBZFobvZnlVB/KsD49ke9tktBdY64iBUNUMbMmqx6TsW34wjclpTBzLTjndPliRXkK4NBVC7uS7IdhzavlEM4p3lZ47gKbNM6s56BfNlHVOAMDdJmzjPf0bRZtKGO07EoZRE9mA2wHl1YnZ0iAcjbMBkb1MRFgTJy/Jjm1/nSAjeNmzUOQKDsCnk1ddi3W0kz5FLAru8K/+9JKf8ku5NWPrTri7QFEnxXrZP0Vg1NF2fzCh2OGFjDrUU9+GkKpanVwB7GNWTcEywJW5E7iyqylgdOHDpoDccsfb0G06J+9p4h2uPL1OISxoW/NRN0RRY=]]></content>
      <categories>
        <category>出游</category>
      </categories>
      <tags>
        <tag>可愛い</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔记(二)]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[暗昧处见光明世界 此心即白日青天 HTML布局 div 布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;head lang="en"&gt; &lt;style type="text/css"&gt; body&#123; margin: 0px;/*这是将页面铺满*/ &#125; div#container&#123; width: 100%; height: 900px; background-color: aliceblue; &#125; div#header&#123; width: 100%; height: 10%; background-color: aquamarine; &#125; div#content_menu&#123; width: 30%; height: 80%; background-color: bisque; float: left; &#125; div#content_body&#123; width: 70%; height: 80%; float: left; &#125; div#footer&#123; width: 100%; height: 10%; background-color: brown; clear: both;/*必须要清除float样式才能正确显示底部否则无法*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt; &lt;div id="header"&gt;头部&lt;/div&gt; &lt;div id="content_menu"&gt;内容菜单&lt;/div&gt; &lt;div id="content_body"&gt;内容主体&lt;/div&gt; &lt;div id="footer"&gt;底部&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; table 布局 1234567891011121314&lt;body marginheight="0px" marginwidth="0px"&gt; &lt;table width="100%" height="950px" style="background-color: darkcyan"&gt; &lt;tr&gt; &lt;td colspan="2" width="100%" height="10%" style="background-color: rebeccapurple"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;左菜单&lt;/td&gt; &lt;td&gt;右菜单&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;底部&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; 表单 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;form&gt; 用户名： &lt;input type="text"&gt; &lt;br/&gt; 密码： &lt;input type="text"&gt; &lt;br/&gt; &lt;input type="submit" value="确认"&gt;/*下面是复选框*/ 你喜欢的水果有？&lt;br/&gt; 西红柿&lt;input type="checkbox"&gt; apple&lt;input type="checkbox"&gt; banana&lt;input type="checkbox"&gt;/*下面是单选框*/ &lt;br/&gt; sex: 男&lt;input type="radio" name="sex"&gt; 女&lt;input type="radio" name="sex"&gt;/*下拉列表*/ &lt;select&gt; &lt;option&gt;12213132&lt;/option&gt; &lt;option&gt;23213231&lt;/option&gt; &lt;option&gt;12414123&lt;/option&gt; &lt;/select&gt;/*文本域*/ &lt;textarea cols="30" rows="30"&gt;请输入&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt; 实现与php文件交互 1234567891011&lt;body&gt; &lt;form action="xxx.php" method="GET"&gt;/*具体的php文件目录*/ 用户名： &lt;input type="text"&gt; &lt;br/&gt; 密码： &lt;input type="text"&gt; &lt;br/&gt; &lt;input type="submit" value="确认"&gt; &lt;/form&gt;&lt;/body&gt; 内联框架----&lt;ifame&gt; 可以理解成，页面套页面？ &lt;iframe src=&quot;....&quot; frameborder=&quot;0&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/iframe&gt; HTMLCSS123456789101112131415&lt;article class="forecast"&gt; &lt;h1&gt;Weather forecast for Seattle&lt;/h1&gt; &lt;article class="day-forecast"&gt; &lt;h2&gt;03 March 2018&lt;/h2&gt; &lt;p&gt;Rain.&lt;/p&gt; &lt;/article&gt; &lt;article class="day-forecast"&gt; &lt;h2&gt;04 March 2018&lt;/h2&gt; &lt;p&gt;Periods of rain.&lt;/p&gt; &lt;/article&gt; &lt;article class="day-forecast"&gt; &lt;h2&gt;05 March 2018&lt;/h2&gt; &lt;p&gt;Heavy rain.&lt;/p&gt; &lt;/article&gt;&lt;/article&gt;123456789101112131415161718192021222324.forecast &#123; margin: 0; padding: .3rem; background-color: #eee; font: 1rem 'Fira Sans', sans-serif;&#125;.forecast &gt; h1,.day-forecast &#123; margin: .5rem; padding: .3rem; font-size: 1.2rem;&#125;.day-forecast &#123; background: right/contain content-box border-box no-repeat url('/media/examples/rain.svg') white;&#125;.day-forecast &gt; h2,.day-forecast &gt; p &#123; margin: .2rem; font-size: 1rem;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞驰人生二刷有感]]></title>
    <url>%2F2019%2F07%2F05%2F%E9%A3%9E%E9%A9%B0%E4%BA%BA%E7%94%9F%E4%BA%8C%E5%88%B7%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[“ 我没想赢，但我不想输。 今年年初的时候和女票一起去看的飞驰人生，这不是我们看的第一部电影，但确是一起看的第一部喜剧片。当时就很想写下自己的感受，但是看了知乎的一些大牛写的精彩绝伦的影评后，我放弃了。他们写的太好了（豹头痛哭） 再加上寒假的事情比较多，就一直拖了下去。最近又要放暑假了😆，所以准备把年初的flag解决掉！ 于是我又二刷了飞驰人生。 首先，不得不说，韩寒拍的这部电影真的打动了我，再加上沈腾自带笑点的buff，可以说这是一部我认为相当优秀的喜剧片了。也许它并不能算是纯喜剧，因为故事结局并不是皆大欢喜，但是导演巧妙地给我们留下了一个蒙太奇般的的结局，这点也是我非常欣赏的地方，你可以认为张弛活着，当然你也可以猜出他的结局，这些并不重要。 重要的是，他为我们展现了一个人，一个热爱着赛车事业的男人，为了他的荣誉，为了责任，为了家人为了朋友而奉献自己的故事。在他的身上，我们看到了自己的影子。 电影中，有着这样一幕，当高华阳还是学员的时候，他问张弛，有没有什么一招必胜的绝技。张弛说： 凭什么这种绝技只有你会别人不会。 你过得每一个弯，都没有再来一次 你犯的每一个错，都有可能断送整场比赛 我们要做的，就是在不断逼近极限的同时，犯更少的错误，在最危险的路段，开着这台车全速前进。 你耍小聪明，赢得了100米，赢不了100公里。 你问我绝招？只有两个字：奉献。就是把你的全部奉献给你所热爱的一切。 是的，张弛真真切切的做到了奉献。他真的把生命，奉献给了他所热爱的事业。 当赛车冲出悬崖的那一刻，世界仿佛停滞了。镜头给了每一个人，每一个平凡的人，每一个张弛在生命中遇见的人。夕阳洒在每一个人的脸上，记星眼里含着泪水，小张飞喂着他的羊，宇强发了疯般的骑上摩托车要去终点，大哥坐在拘留所里默默的望着窗外。 而张弛，坐在赛车中冲向夕阳的他，在他的眼里，我看到了释然，却也看到了不舍。 影片结尾有个彩蛋，他的儿子找来同学的爸爸，来比速度，然而人家是飞行员，都不在一个量级上。眼看飞机飞过头顶，小张飞掏出一枚游戏币，投入了虚幻的投币口，赛车直接变身飞机，飞进了二次元的世界。 这是一个梦，一个甜蜜的，不忍戳穿的梦。 我们每个人，都做过这样的梦。在经历了无数努力、无数坎坷、留下无数汗水之后，却仍然获得一个不甚满意的结局。我们不愿接受，却又不得不接受。 今天只有残留的躯壳， 迎接光辉岁月， 风雨中抱紧自由 一生经过彷徨的挣扎 自信可改变未来 问谁又能做到 影片中致敬了许多经典，有光辉岁月，有守望先锋，有圣斗士星矢，有朴树，也有曾经的拉力冠军。 影片中没有反派，更多的，是对比。一个昔日的落魄车王，一个年轻多金的高富帅，他们孰强孰弱或许难下定论，但我觉得，韩寒想表达的是，你说条条大路通罗马，可偏偏有人就生在罗马。 难道说我们的奋斗就没有意义了吗？ 显然不是的。 只有一个人对自己失去信心的时候，他才是真的过时了。用热血浇灌的事业，不会让你失望。 电影里还有一句话 我没想赢，但我不想输。 我女票特喜欢这句话，这句话也成为了她的众多人生格言中的一条。 但是我，并不是特别能理解这句话。工科男的清奇脑回路 想赢就是想赢，为什么非要说成不想输呢？或许等我经历更多的事情以后，就会理解这种心境吧。 我们继续回到电影，最后想说的，就是关于友情。 人在顺境时候的友谊，可能不是那么坚固的。 我们看到了落井下石，看到了成人世界的虚伪，看到了形形色色的面具仿佛就在我们身边游荡。今天他搂着你肩膀说：我这辈子就你这个兄弟。你感动的都快哭出来了，明天呢，你破产了，他绝对离你远远的。张弛经历过这样的无助，也看透了所谓的人间冷暖。 当你如日中天的时候，不要对别人掏心掏肺，因为某些人的虚伪、奉承、巴结、讨好，是已经深深的烙在骨子里，你想也想不到的。 《平凡之路》 我曾经跨过山河大海 也看过 人山人海 我曾经拥有这一切 转眼都飘散如烟 十年前你说没有什么能够阻挡，你对自由的向往。 十年后你说平凡才是唯一的答案。 不管怎样，我们所热爱的一切，是我们的选择。 心之所向，无远弗届。]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TECHNICAL WRITING IN ENGLISH]]></title>
    <url>%2F2019%2F07%2F04%2FTECHNICAL-WRITING-IN-ENGLISH%2F</url>
    <content type="text"><![CDATA[外教蛮帅的哦！ Three Golden Rules Focus on READABILITY Focus on STRUCERS Don’t forget ETHICS Appropriate language(READABILITY) Level of Formality say→ state think → believe put out → publish find out → investigate for sure → with certainty people → individuals Avoid contraction x don’t aren’t isn’t √ do not No emotion DON’T USE ANY ADJCTIVES Such as: beautiful; surprising Can only use: hope fear disappointment satisfaction Don’t be vague few enough a lot Practical and Precise Sentence Pain and simple 1.Length: short over 30 words are hard to read 2.One general idea pre sentence 3.Use more passive forms Transform too complex academic writing into clear via: Deleting redundancies（冗余） Dividing long sentences into many shorter sentences Replacing ‘hundred-dollar words’ with ‘ten-cent words’ whenever possible 意思是说，不要为了用高级词汇而用高级词汇 Being factual, clear and emotion-less, instead of being metaphoric(隐喻) or poetic Structure REMEMBER----------- Scientific writing is NOT literature “I M R A D ” theory I -----------Introduction 直入主题，不拖泥带水 M----------Materials and Methods 理论事实支撑 R----------Results 总结 A----------(And) D----------Discussion Be Ethical and Honest a) Accuracy ----------Be honest in your results b) Originality -------Your finding must be new --------DON’T SEND the same paper to several publishers c)Plagiarism --------Do not take credit for someone else’s work.(不要把工作归功于别人) Different between China and Western Countries Don't be too modest Western people are likely to promote their own selves Just like Trump💩 They favors individuality and personal success You mustn’t feel embarrassed about putting forward your findings, and those of others, as individuals. Go straight to the point Paragraphs and Sentences A paragraph is a series of sentences that are organized and coherent, and are all related to a single main idea, a topic How they work? a series of brief examples or a single long illustration of a general point; It might describe a place, character, or process; narrate(讲述) a series of events; compare or contrast two or more things; classify items into categories; or describe causes and effect. TOPIC SENTENCES Sentences that contain topic and the controlling idea EXAMPLES: People can avoid plagiarizing by taking certain precautions There are several advantages to online education Examples or explanations --------The body Conclusion or link This last part summarises the connections between the information discussed in the body of the paragraph and the paragraph’s controlling idea. It can also link the paragraph with the next one and to the main topic of the essay More tips Be consistent with - Don’t switch point of view.(不要切换观点) - Stick with the same verb tense (past or present) Use transition words - first of all - for example - in the other words - in fact - moreover - instead of Repeat key words and phrases(短语) Another Golden rule: Make short sentences BUT DO NOT just for writing short sentences.When there are only short sentences, it feels robotic or choppy. Vary length from 12 to 20 words. Our goal is to make it easier to understand. E-mails]]></content>
      <categories>
        <category>科研英语写作</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔记(一)]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[“ 爱你所爱，无问西东 基础元素 声明 &lt;!DOCTYPE&gt;用于说明页面的HTML版本 &lt;head&gt; &lt;body&gt;具体内容 &lt;title&gt;显示在标签栏上 &lt;h1&gt; &lt;h2&gt;.......标签 &lt;p&gt;段落 &lt;a href=&quot;&quot;&gt;xxx&lt;/a&gt;把xxx作为超链接 &lt;img src=&quot;&quot;&gt;图片 &lt;br/&gt;换行（空元素） 常用属性 &lt;h1&gt;:align 对齐方式 right left center &lt;a&gt;:target 在何处打开链接 &lt;body background&gt; 背景图片 &lt;body bgcolor&gt; 背景颜色 通用属性 class类名 &lt;style type=&quot;&quot;&gt;用于引入css属性 格式化 &lt;b&gt;加重 &lt;big&gt; &lt;em&gt; &lt;i&gt;斜体 &lt;strong&gt; &lt;sub&gt;下标 &lt;sup&gt;上标 &lt;del&gt;删除字（即横划线） &lt;ins&gt;插入字 样式 标签 &lt;style&gt;样式定义 &lt;link&gt;资源引用 &lt;img&gt; &lt;a&gt;链接标签 文本链接 图片链接 属性 rel=&quot;stylesheet&quot; 外部样式表 type=&quot;text/css&quot; 引入文档类型 margin-left 边距 alt 元素属性声明（在图片加载不出来的时候仍能显示的文本） name 文档内链接（用于跳转到注释处） 例： 12&lt;a name="tips"&gt;hello&lt;/a&gt;&lt;a href="#tips"&gt;跳转到hello&lt;/a&gt; 插入方法 外部样式表 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; 直接在&lt;head&gt;标签里加入就可以，相关的元素直接就以mystyle.css中的样式显示。 内部样式表 1234&lt;style type="text/css"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt; 这是定义了body元素和p元素的样式。 表格 &lt;table&gt;里面可以设定单元格边框border 设定单元格大小cellpadding 设定单元格间距cellspacing 设定单元格颜色bgcolor &lt;caption&gt;表格标题 &lt;th&gt;第一行表头 &lt;tr&gt;表格的定义 &lt;td&gt;一行的表格数据（要放在&lt;tr&gt;里） &lt;ul&gt;标签 列表 无序列表 相关标签 &lt;ul&gt;定义 &lt;li&gt;项 属性 前面的标号：（在&lt;ul&gt;中定义type属性 disc实体圆 circle空心圆 square方块 有序列表 &lt;ol&gt;定义 &lt;li&gt; 属性 编号方式： A a I罗马数字 start 嵌套列表 即列表中再嵌套一个列表 &lt;ul&gt; &lt;ol&gt; &lt;li&gt; 自定义列表 默认没有编号 &lt;dl&gt;定义 &lt;dt&gt;项名 &lt;dd&gt;具体描述 HTML块 块元素，总是以新行开始，不会连在一起。如&lt;h1&gt; &lt;p&gt; ul div元素 &lt;div&gt;元素，用于引入css样式。 用法如下： 在head中添加css文件链接&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt; 然后在body中添加 123&lt;div id="xxx"&gt; &lt;h&gt;.......&lt;/h&gt; &lt;/div&gt; 然后在xxx.css中定义id#xxx {....}即可。 span元素 只用于文本元素的div的特殊下属 1234567891011&lt;head lang="en"&gt; &lt;style type="text/css"&gt; span&#123; color: blue; &#125;&lt;/head&gt;&lt;body&gt; &lt;div id="divspan"&gt; &lt;p&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++学习笔记(一)]]></title>
    <url>%2F2019%2F07%2F02%2Fc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%9C%2F</url>
    <content type="text"><![CDATA[吾辈青年岂容卸甲，唯有自请长缨，日夜兼程。 变量声明 #include&lt;sdtio.h&gt;是c的头文件，而cpp的头文件是#include&lt;iostream&gt; 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;int sum(char *p,char *f,int m,int n)&#123; double s=0.0; int i,j,c,d; for(i=0;i&lt;m;i++) s+=(*(p+i)-'0')*(pow(10,m-i-1)); for(j=0;j&lt;n;j++) s+=(*(f+j)-'0')*(pow(10,n-j-1)); char a[100]; sprintf(a,"%.f",s); puts(a); return 0;&#125;int main()&#123; char a[20],b[20]; int m,n; int sum(char *p,char *f,int m,int n); char *p; char *f; scanf("%d %d",&amp;m,&amp;n); scanf("%s",a); scanf("%s",b); p=a; f=b; sum(p,f,m,n); return 0;&#125;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构好难 数据结构 - 幕布 数据结构 串 链式存储 索引存储 带长度的索引表 带末指针的索引表 带特征位的索引表 链式模式匹配算法 精髓：定义三个指针------first,sptr,tptr 用first指示当前剩余字符串中的第一个 用sptr从first位从前往后匹配 用tptr指示待匹配的值并后移 一旦不一致，first后移，sptr重置，tptr重置 数组 稀疏矩阵三元组表 三元组=（行i，列j，非零元素值）——行优先 数据结构描述 三元组----先用一个node类型的一维数组储存一类值，然后在值内分配 i,j,v三个属性，从而超越了二维属性的限制 转置算法 本来应该直接把存储的行号列号交换一下就可以，但这样得到的是列优先的稀疏矩阵，我们需要行优先的 第一步只是把“行数”和“列数”转换，并未对实际矩阵产生影响；第二步才是按列查找（因为它们转置成了行，而我们要以行优先储存），双重循环，才能实现排序！从0开始（因为它们是之后的行号） 栈 定义 形象结构 入栈 出栈 队 定义 循环队列 形象示例 置空队 入队 出队 关于返回指针的函数在主函数中的调用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线代笔记哦]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%BA%BF%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[要不要点进来看看呀 线性代数 - 幕布 线性代数 矩阵 等价矩阵 A和B经过一系列初等变换可以相互转化 三角矩阵 分块矩阵 转置 求逆 共轭矩阵 转置矩阵 对称矩阵 反对称矩阵 此矩阵主对角线上元均为0 逆矩阵 （AB)(-1)=B(-1)*A^(-1) 伴随矩阵法求逆矩阵 Ax=B型 (A|B)=(E|A^(-1)*B) 右侧为代求x xA=B型 上下拼，然后初等列变换 初等矩阵均为逆矩阵 初等矩阵（3种） &lt;span class=&quot;content mubu-node&quot; style=&quot;line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;&quot;&gt;上下拼，然后初等列变换&lt;/span&gt; &lt;span class=&quot;content mubu-node&quot; style=&quot;line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;&quot;&gt;交换行&lt;/span&gt; &lt;span class=&quot;content mubu-node&quot; style=&quot;line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;&quot;&gt;在第i行乘k&lt;/span&gt; &lt;span class=&quot;content mubu-node&quot; style=&quot;line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;&quot;&gt;将第j行k倍加到i行&lt;/span&gt; 对任意矩阵进行初等行变换相当于左乘初等矩阵 对任意矩阵进行初等列变换相当于右乘初等矩阵 对角矩阵 阶梯形矩阵 只是阶梯状，无任何约减 最简形矩阵 非零行的第一个非零元为1，且这些非零元所在的列的其他元素都是零。 标准形矩阵 行最简形矩阵再经过初等列变换，可化成标准形。 伴随矩阵 性质 注意其实它的所有位置都转置了 行列式 |A|或det A sgn()即逆序数，后面求和中有n!个连乘式子，需要满足每行每列元素只出现一次，但具体位置并不固定（三阶较为直观，可以用对角线法，高阶非常复杂，无法直接套用） 性质 即|kA|=k^n*|A|​ 按行（列）展开 余子式 A的一个k阶余子式是A去掉了k行与k列之后得到的(m-k)×(n-k)矩阵的行列式。 代数余子式 余子式只计算去掉某行某列之后剩余行列式的值，而代数余子式则需要考虑去掉的这一个元素对最后值正负所产生的影响。 当非对应行的元与Aij相乘，则乘积之和为0，注意：不是单项为0 特殊行列式 主对角上三角行列式 上三角是主对角线元素乘积​ 斜下三角行列式 注意前面的逆序！​ 箭型行列式 解法 两三角型行列式 解法 a,b不等 解法—拆行法 更复杂的例子 更更复杂的例子 解法（加边升阶法) 两条线型行列式 范德蒙德型行列式 解法（化成范德蒙德行列式）]]></content>
  </entry>
  <entry>
    <title><![CDATA[不朽的文明]]></title>
    <url>%2F2019%2F03%2F28%2F2019-03-28-%E4%B8%8D%E6%9C%BD%E7%9A%84%E6%96%87%E6%98%8E%2F</url>
    <content type="text"><![CDATA[——读《三体》有感。 一百五十亿光年的范围内充满杀机。 “地球往事”三部曲，就这样为我们展开了这样一幅如此惊心动魄，充满黑暗却未失人性的图景。刘慈欣告诉我们，光年之外的宇宙是这样的。 “这是一个捉摸不透的黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼：他必须小心，因为林中到处都有与他一样潜行的猎人，如果他发现了别的生命，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭，这就是宇宙文明的图景。” 他将人类的文明发展当作一个整体的过程置于宇宙的背景之下，透过文字，描写众生，将各种人在危机面前的心理活动进行了细致描写，可以说，他对人类的批判的深刻性达到了科幻小说从未有过的高度。那些沉重的道德问题、责任问题、信仰问题，为《三体》这部硬科幻注入了弥足珍贵的人文基因，也给我们这些读者，留下了更加广阔的思考空间。 在作者的笔下，通过一个极其大胆的想法，人类第一次进行了恒星级宇宙广播，也让另一个高等文明——三体文明，知道了人类文明的存在。当两个文明相遇，猜疑，便在充满不确定性的黑暗宇宙里悄然蔓延。 一边是气候适宜，稳定运转的地球，一边是运动轨迹无解，酷热与极寒交织三体世界。对于三体文明而言，地球就像是天堂，是梦，是他们想也不敢想的奢望。但文明的贪婪，从未消失过。于是三体人，决定占领地球。 面对三体文明的攻击，人类竟毫无反手之力。人类，在三体人眼里就像是虫子，可悲、弱小的虫子一样，等待着不可避免的灭亡。 然而，谁说虫子会灭亡呢？ “人类竭尽全力消灭它们，用尽各种毒剂，用飞机喷洒，引进和培养它们的天敌，搜寻并毁掉它们的卵，用基因改造使它们绝育，每个办公桌下都有像苍蝇拍这种击杀它们的武器……这场漫长的战争伴随着整个人类文明，现在仍然胜负未定，虫子并没有被灭绝，它们照样傲行于天地之间。把人类看做虫子的三体人似乎忘记了一个事实：虫子从来就没有被真正战胜过。” 是的，虫子从未被真正战胜，即使是双方实力如此悬殊。 三体文明绞尽脑汁，破壁计划、智子封锁、水滴攻击……一次又一次的打击，依旧有人心怀希望，脚下步履不停，因为人类拥有与生俱来的生命尊严，而不屈的灵魂，不会被打败！ 刘慈欣想给我们呈现的，并不仅仅是三体与人类之间的战争，而是对于文明的思考。三体文明已经远远超过人类，但当人类将它的空间位置暴露之后，立刻遭受了其他更高级文明的毁灭性打击。而宇宙中的文明，多到难以想象，有些文明，我们甚至永远无法观测—因为他们在更高维度的空间，但文明之间的掠夺，却从未停止。作者提出宇宙社会学，向我们介绍了文明的两大公理——第一，生存是文明的第一需要。第二，文明不断增长和扩张，但宇宙中的物质总量保持不变。毫无疑问，宇宙间是赤裸裸的生存法则：高等文明绝不友善，会毫不犹豫消灭宇宙中任何它认为有威胁的低等文明。 那么，文明存在的意义究竟是什么呢？在书中，人类全部的荣誉、努力、勇敢和辉煌，被歌者文明的清理操作而轻易终结。如果真的存在这样的文明，人类的努力又是否有意义？ 显然，质疑人类文明的人陷入了虚无主义的泥淖。人类文明，从开蒙伊始，发展到如今，必然衍化出它独特的意义。我们探索未知，用道德约束人心，诗歌流露人性光辉。海洋的最深处我们已经到达，探测器正飞向柯伊伯带去延伸人类认知边界，对于人类生命的探索科学家从未停下脚步。这还不够吗？人类文明的意义，贯穿整个人类的发展史，体现在方方面面。 我们，仅仅是这文明宏伟历程中的一个小小过客，岁月长河漫漫，不朽的，是文明本身。 不如给岁月以文明，心向寰宇，风雨平生。]]></content>
      <categories>
        <category>读后感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写给二〇一八的年终总结]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%86%99%E7%BB%992018%2F</url>
    <content type="text"><![CDATA[这是我写下的第二篇年终总结。 不要问我第一篇是哪一年的(我也记不清了) 是什么促使我下定决心写一篇年终总结呢？因为今年，与众不同。 今年反生了很多事，多到我猝不及防，却一件又一件的像梦一样倏忽而过。但我还是过完了这精彩而又惊心动魄的一年。 高三·寒窗十载，跋涉万里 我终究来到了高考面前。 曾经无数个日日夜夜念叨着的高考，敬仰着的高考，终于见到了它的真容。 在我的印象里，高考应该是刻板严肃的老学究，背着个手，踱来踱去，谁偷懒了，就用戒尺在他手背上敲上一下。在他面前，任他是多么捣乱的学生也不敢造次。 在我的印象里，高三应该是最灰暗的日子，没日没夜，废寝忘食(好像有点过了)，在一道道解析几何，导数大题，理综压轴的泥淖里拼命挣扎，在宿舍、教室、食堂三点一线中日复一日。 直到我来到高三，我才发现，事实并非如此。 去年暑假，我们搬到了高三教学楼，紧凑的教室并没有想象中的压抑。四只风扇在头顶乱舞，窗边的盆栽努力的活着(几乎没人浇水)，教室朝南，阳光很好，空气中悬浮的粉笔灰看得清清楚楚。我喜欢这儿。 开学全市统考如约而至，糟糕的成绩诉说着暑假的潇洒(捂脸)。扶我起来，我还能学！ 我开始了高三模式。 又买了一本练习题？刷！发现某考卷不错？刷！一言不合，就刷刷刷！好的我成功的陷入了刷题的死循环。当然，刷题应该是有效果的，但效果持续时间不长，且仅在小考中发挥(要哭了)。我有一个本子，记录着我高中三年大大小小每一次正规考试的年级排名，就看呀那跌宕起伏的折线图，哟这里好高，一看，噫，原来是月考，哟这里咋这么低，一看，期末/模拟……对，我就是那种一到大考就瞪不起眼的人，且成功将这种体质延续到了高考，当然这是后话了。 刷题的路上，全班每一个人，都在疯狂前进。 ​ 我和冰哥成了刷题上的战友，(不过冰哥比我刷的快)，一本又一本金考卷、押题卷、衡水金卷就这样在我们的手中变成了废纸一堆，然而还是买多了(暴风哭泣)，家里还有一摞练习题。（高考完那个暑假还琢磨怎么卖掉–有需要的小伙伴请联系我!) 高考的脚步声近了。 我还清楚得记得，在2018年1月1日那天，我们班级的元旦活动。 那天可真热闹呀，Ivy给我们唱了一首歌(唱的超好听)，然后娜姐表演了一个魔术(真的好厉害！)，华姐给我们用&quot;标准的普通话&quot;深情朗诵，当然，我们每个同学都录了祝福的话，留给多年后的自已一个回忆。我还记得wyp说了&quot;希望我们青年一辈，冷风热血，荡涤乾坤&quot;，(果然不忘嘲讽我)，把我乐的。不过呀说到wyp我就想起了西游记里高三下学期我一件比较后悔的事情。之前我们是同位，关系应该算很好了，不过他总是喜欢嘲讽我？或者找我事？一开始我也就当玩笑听听，但是应该是持续了相当长一段时间，我真的受不了了简直烦死我了，于是某天午休当他再一次&quot;骚扰&quot;的时候，我脾气蹭的一下上来了，然后发生了一些很不愉快的事情。于是从那天开始，wyp与我，绝交。到今天也没有再说过一句话。虽然这对我来确实没什么，但是还是觉得有点可惜。怎么说呢，希望他未来还能像少年时那样脾气好，就这样吧，相忘于江湖也不失是一个好归宿。 元旦一过，大家又立刻投入到紧张的备战当中。 期末、一模二模三模、无数次理综、数不清的卷子，排名变了又变（当然学霸还是学霸，像我这样的学酥就只能起起伏伏，飘忽不定）。排名于我而言早已麻木，我要的是熟练，我要的是仔细！错误的原因有很多，但结果只有一种。我只有把所有的原因一一避开，才能拥有最终的正确。于是，我依旧在孜孜不倦的刷题。 我习惯了教室午休，习惯了一个人去食堂。 我习惯了第二节晚自习下课冲出教室，去操场跑圈，去体育馆后面昏黄的小道上走一走，闻一闻花香，让疲惫了一天的自己放松一下(要不然写题写到脑仁疼)。 高三，是我对五十八中了解的最细致的一年。 从初春到仲夏，我留心了校园的花花草草。虽然我不知道它们叫什么，但我真的很喜欢它们的味道，那一丛一丛的，开得顾盼生姿的花，洁白的令我陶醉。 余路还要走多久，你牵着我的手。 高考终究还是来了。 两天。四场考试。三年就画上了句号。 并没有我想象中的顺利，虽然题有我想象中的简单，但是我还是无法控制的紧张过度，留下了很多的遗憾。 但不管怎样，我还是我，我不后悔。 踽踽独行，不惜万里蹀躞。 高考，是终点也是起点。 只是，从此以后，万里长路，山河寂寥。 我的大学·西军电 9月，梦想再一次起航。 远离了故土，远离了海风，远离了海，远离了亲人和朋友，我来到了西安，这个古老与现代并存的城市。 说实话，一方水土养一方人，西安这里给我留下的第一印象就是，这的人懒。 为什么这么说呢，大早上出去买早餐，都七点多了，**大街上没有几家店开门！**我真的纳了闷了早餐店不应该早早的开门吗？还是夏天，天亮的早，为什么不愿意赚钱呢？后期走访(购物)发现，好多店都是十点以后开门(郁闷)。 好了说正事。 来到了西电，哇新校区好漂亮呀，开心开心。 军训为什么十四天啊喂！为什么这里下午这么晒啊！为什么教官这么认真的摧残我们啊！看到小伙伴们的军训那么水，还在练军体拳的我默默在心中留下了眼泪。 万万没想到！在我们艰苦卓绝的不懈努力下，求的雨终于！在汇报演出的那！天！下！了！本来一直是暴雨，都说要取消演出了，然而学校骚操作你永远也想不到，给我们每个人，发了一套塑料雨衣，对没错，我们是披着雨衣踢完的正步。冰冷的雨水就这样在我脸上胡乱的拍打。（自己求得雨，哭着也要把它淋完.jpg） 好吧，军训除去晒和累，还是很好玩的。 我们的连长比我们大了五岁左右吧，是一个非常可爱的小伙子。我们是他第一次带的学员，他本身也是军校大一的学生。他总是跟我们讲，不要老玩游戏，好好把学习搞上去，不要像他一样大三了再去考军校当兵。我听出了他的无奈。 亲爱的连长，也请你继续完成你的梦想！ 之后呢，很开心，遇到了一群很可爱的小伙伴，包括我的舍友兄弟们以及院里的同学呀。 虽然社团面试无一例外全都被刷了，但是我也没有那么不开心(才怪)。 接下来开始正式大学学习生活啦。 很努力的学高数。 然而。 天不遂人愿。 期中，只有80分。 好吧，让我再熟悉熟悉题型，期末杀他个片甲不留！ 接下来是碎碎念时间。 西安这里冬天7点天还是黑的，给我一种错觉还是晚上，所以经常性堕落(起的好晚)，这跟我头一天12点睡似乎也有关系(捂脸)。 舍友们还是一群很上进的小伙伴。有好多大佬呀。我要加把劲啦。 校园里撒狗粮的好多呀，猝不及防。 我天天吃这么多咋还没长胖呀(逃)。 感谢的人 首先呢，当然是感谢我妈妈啦！感觉妈妈好辛苦但是我却抽不出时间和妈妈打电话……那就今天晚上吧！很感谢妈妈的关心，虽然不好意思说但我真的爱您呀妈妈！希望2019年，时光能善待我妈妈，她身体健健康康平平安安我就超级开心啦！ 然后呢，是我的小仙女品子啦！手动比心比心比心。谢谢你一直陪伴着我，今天就是我们恋爱5周年的Anniversary啦，好开心呀！虽然我们一直异地，但是我期待将来某一天能有一个我们自己的小窝！努力去追寻自己的梦想吧！ 还有我高中陪伴了我两年的同位老铁家傲，前不久闲聊，字里行间还是透露出浓郁的上世纪知识分子的气息哈哈，给我剪辑的宣传片提供了建议，很感谢啦！希望你在南昌不要因为设计图纸搓光面包。加油老铁！ 以及多年好友冰哥，大学里的舍友们，因为你们，我不再独身一人。 愿你我一路繁花似锦，山水相拥，青山为伴。 Lyric Time 2018再见 作为一个信安狗文艺青年怎么能忘记抒情呢？ 2018，我走过很多的路，流下了很多的汗，有很多欢笑，也有不少泪水。 身经百战，我从没想过放弃。 单枪匹马，我完成了人生的第一次跨越。 2018，我留下几万字的摘抄，读过许多书。 我们都说过去了，风轻云淡，我们相信未来依旧有生生不息的希望和不期而遇的温暖。 生活虽然可能荆棘遍地，但仍不能阻止你一路高歌。 生命，其实最后总能成诗。 把酒祝东风，且共从容。 2018，谢谢你，这段日子，我很珍惜。 再见了，2018。 2019你好 2019，希望是我从小白蜕变成dalao的起点。 2019，希望我的家人平安健康，希望我爱和爱我的人一切顺利，希望日子里仍有感动长在。 年少时的热血，如今仍在沸腾。面对信息安全，我将不遗余力。 曾经承诺过要读很多书，留下很多随笔。2019，我不会忘记。 想要结识更多的朋友，想要学业在上一层楼。 想把岁月唱给你听。 2019，希望一切，都是最好的样子。 2019，加油。 我的新年flag]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pika]]></title>
    <url>%2F2018%2F12%2F29%2FPika%2F</url>
    <content type="text"><![CDATA[Pika Pika!]]></content>
      <tags>
        <tag>可愛い</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创造，让未来无限可能]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%88%9B%E9%80%A0%EF%BC%8C%E8%AE%A9%E6%9C%AA%E6%9D%A5%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%2F</url>
    <content type="text"><![CDATA[/----写在前面----/ 曾经，有梦。 如今，未忘。 我不会选择做一名普通人。 自命不凡是天赋人权——只要我能。 我寻求机遇，而非安稳。 我也从不愿去做顺民， 在国家的保障下变得卑躬沉沦。 我要尝试那精心的冒险； 去梦想也去创造，去失败也去成功。 我拒绝失去激励而获得救助； 我宁愿接受生活的挑战，不甘心保有确定的现状； 成就带来的欣喜远比乌托邦式的平静更令我向往。 我不会为福利而牺牲自由； 也不会为施舍而放弃尊严。 在任何大师面前我不会胆怯； 在任何威胁面前也决不屈服。 我的天性是昂然挺立，自豪无惧； 按照内心的方式敢想敢为。 我享受自我创造产生的果实； 坦然面对这个世界，然后说： 此生，拜上帝之助，我有所作为。 充满鲜花的世界到底在哪里 如果它真的存在那么我一定会去 我想在那里最高的山峰矗立 不在乎它是不是悬崖峭壁 用力活着用力爱哪怕肝脑涂地 不求任何人满意只要对得起自己 关于理想我从来没选择放弃 即使在灰头土脸的日子里 也许我没有天分 但我有梦的天真 我将会去证明用我的一生 也许我手比脚笨 但我愿不停探寻 付出所有的青春不留遗憾 向前跑 迎着冷眼和嘲笑 生命的广阔不历经磨难怎能感到 命运它无法让我们跪地求饶 就算鲜血洒满了怀抱 继续跑 带着赤子的骄傲 生命的闪耀不坚持到底怎能看到 与其苟延残喘不如纵情燃烧吧 有一天会再发芽 未来迷人绚烂总在向我召唤 哪怕只有痛苦作伴也要勇往直前 我想在那里最蓝的大海扬帆 绝不管自己能不能回还 失败后郁郁寡欢 那是懦夫的表现 只要一息尚存请紧握双拳 在天色破晓之前 我们要更加勇敢 等待日出时最耀眼的瞬间 向前跑 迎着冷眼和嘲笑 生命的广阔不历经磨难怎能感到 命运它无法让我们跪地求饶 就算鲜血洒满了怀抱 继续跑 带着赤子的骄傲 生命的闪耀不坚持到底怎能看到 与其苟延残喘不如纵情燃烧吧 为了心中的美好 不妥协直到变老]]></content>
      <tags>
        <tag>梦想</tag>
      </tags>
  </entry>
</search>
